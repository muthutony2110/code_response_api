from flask import Flask, request, jsonify
from filters.filters import is_greeting
from message import get_greeting_response, get_decline_message
from querychecker import classify_text_with_deepseek
from ollama_client import query_ollama, split_message_and_code
from mssql_client import (
    save_history_with_task,
    get_history_by_task
)

app = Flask(__name__)

@app.route("/generate", methods=["POST"])
def generate():
    try:
        data = request.get_json()
        prompt = data.get("prompt", "").strip()
        user_id = data.get("user_id", "guest").strip()
        task_name = data.get("task_name", "").strip()

        if not prompt or not task_name:
            return jsonify({
                "response": {
                    "message": "‚ö†Ô∏è Please provide both 'prompt' and 'task_name'.",
                    "code": ""
                }
            })

        # Greeting detection
        if is_greeting(prompt):
            return jsonify({
                "response": {
                    "message": get_greeting_response(),
                    "code": ""
                }
            })

        # Classify prompt
        classification = classify_text_with_deepseek(prompt)
        if classification == "Not coding-related":
            return jsonify({
                "response": {
                    "message": get_decline_message(),
                    "code": ""
                }
            })
        elif classification == "Unclear":
            return jsonify({
                "response": {
                    "message": "ü§î I'm not sure if it's about programming. Please clarify.",
                    "code": ""
                }
            })

        # Build context using only the same user and task
        history = get_history_by_task(user_id, task_name, limit=3)
        context = ""
        for item in history:
            context += f"User: {item['prompt']}\nAssistant: {item['message']}\n"

        full_prompt = f"{context}User: {prompt}\nAssistant:"
        raw_response = query_ollama(full_prompt)
        structured = split_message_and_code(raw_response)

        # Save response
        save_history_with_task(user_id, task_name, prompt, structured['message'], structured['code'])

        return jsonify({"response": structured, "task_name": task_name})

    except Exception as e:
        import traceback
        traceback.print_exc()
        return jsonify({
            "response": {
                "message": f"‚ùå Internal Server Error: {str(e)}",
                "code": ""
            }
        }), 500


if __name__ == "__main__":
    app.run(port=8600)


import pyodbc

# Database connection
def get_connection():
    return pyodbc.connect(
        'DRIVER={ODBC Driver 17 for SQL Server};'
        'SERVER=SYSLP720;'
        'DATABASE=deep;'
        'Trusted_Connection=yes;'
    )

# Save conversation to DB
def save_history_with_task(user_id, task_name, prompt, message, code):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("""
        INSERT INTO ConversationnewHistory (user_id, task_name, prompt, message, code)
        VALUES (?, ?, ?, ?, ?)
    """, (user_id, task_name, prompt, message, code))
    conn.commit()
    conn.close()

# Get recent conversation history for user & task
def get_history_by_task(user_id, task_name=None, limit=10):
    conn = get_connection()
    cursor = conn.cursor()

    if task_name:
        cursor.execute("""
            SELECT TOP (?) prompt, message, code
            FROM ConversationnewHistory
            WHERE user_id = ? AND task_name = ?
            ORDER BY id DESC
        """, (limit, user_id, task_name))
    else:
        cursor.execute("""
            SELECT TOP (?) prompt, message, code
            FROM ConversationnewHistory
            WHERE user_id = ?
            ORDER BY id DESC
        """, (limit, user_id))

    rows = cursor.fetchall()
    conn.close()
    return [{"prompt": row[0], "message": row[1], "code": row[2]} for row in rows]

# Get all history across all users/tasks
def get_all_history():
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("""
        SELECT user_id, task_name, prompt, message, code
        FROM ConversationnewHistory
        ORDER BY id DESC
    """)
    rows = cursor.fetchall()
    conn.close()
    return [
        {
            "user_id": row[0],
            "task_name": row[1],
            "prompt": row[2],
            "message": row[3],
            "code": row[4]
        }
        for row in rows
    ]

# Delete all history of a user
def delete_user_history(user_id):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("DELETE FROM ConversationnewHistory WHERE user_id = ?", (user_id,))
    conn.commit()
    conn.close()

# Delete a specific prompt of a user
def delete_specific_prompt(user_id, prompt):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("""
        DELETE FROM ConversationnewHistory
        WHERE user_id = ? AND prompt = ?
    """, (user_id, prompt))
    conn.commit()
    conn.close()

# Delete all history of guest user
def delete_guest_history():
    delete_user_history("guest")

# Get the earliest task name for a user (optional use)
def get_latest_task_name(user_id):
    conn = get_connection()
    cursor = conn.cursor()
    cursor.execute("""
        SELECT TOP 1 task_name
        FROM ConversationnewHistory
        WHERE user_id = ?
        ORDER BY created_at ASC
    """, (user_id,))
    row = cursor.fetchone()
    conn.close()
    return row[0] if row else None

POST http://127.0.0.1:8500/generate

GET http://127.0.0.1:8500/history?user_id=user123

DELETE http://127.0.0.1:8500/history/task?user_id=user123&task_name=ecommerce_sql

